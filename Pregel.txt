#Pregel
##0.Abstract
    背景：社交网络，数十亿顶点、数万亿边；
    以顶点为中心的策略：
        程序使用一系列的迭代过程来表达，在每一次迭代中，每个顶点会接收来自上一次迭代的信息，并发送信息给其它顶点，同时可能修改其自身状态以及以它为顶点的出边的状态，或改变整个图的拓扑结构。


##1.Introduction
    路径问题：最短路径、可达路径；匹配问题：结构匹配、语义匹配；聚类算法；PageRank算法；
    
    目前还不存在一种在大规模分布式环境下，可以基于各种图表示方法来实现任意图算法的，可扩展的通用系统；
    
    处理大规模图的算法：
        ①为特定图应用定制相应的分布式实现；不通用；
        ②基于现有的分布式计算平台(如MapReduce)；不理想；
        ③使用单机的图算法库；不能大规模；
        ④使用已有的并行图计算系统(Parallel BGL、CGMgraph)；无容错等分布式系统必要特性；
    
    Pregel：大规模、容错、API有效表达各种图算法；
        vertex-centric  以顶点为中心
        superstep
        synchronicity  同步


##2.Model of Computation
    overall：
        读取输入初始化该图，当图被初始化好后，运行一系列的superstep直到整个计算结束，这些superstep之间通过一些全局的同步点分隔，输出结果结束计算。
    计算的输入是一个有向图：
        顶点：有一个string顶点描述符
        边：与源顶点、目标顶点关联
    迭代计算：
        在每个superstep中，顶点的计算都是并行的，每个顶点执行相同的用于表达给定算法逻辑的用户自定义函数。每个顶点可以修改其自身及其出边的状态，接收前一个superstep(S-1)中发送给它的消息，并发送消息给其他顶点(这些消息将会在下一个超级步中被接收)，甚至是修改整个图的拓扑结构。在这种计算模式中edge并不是一等公民,因为没有相应的计算运行在边上。
    算法的终止：
        算法的终止取决于是否所有的顶点都已经“vote”标识其自身已经达到“halt”状态了。在第0个superstep，所有顶点都处于active状态，所有的active顶点都会参与所有对应superstep中的计算。顶点通过将其自身的status设置成“halt”来表示它已经不再active。这就表示该顶点没有进一步的计算需要执行，除非被再次被外部触发，而Pregel框架将不会在接下来的superstep中执行该顶点，除非该顶点收到其它顶点传送的消息。如果顶点接收到消息被唤醒进入active状态，那么在随后的计算中该顶点必须显式的deactive。整个计算在所有顶点都达到“inactive”状态，并且没有message在传送的时候宣告结束。
    计算的输出是所有顶点输出的集合：
        通常是一个与输出同构的有向图，但不是必须，因为计算过程中可以添加或删除顶点和边。比如聚类算法可能是从一个大图中生成的非连通顶点组成的小集合。
    
    异步批量传递消息
    superstep


##3.The C++ API
    继承Vertex类：
        Compute；vertex_id；superstep；GetValue；MutableValue；GetOutEdgeIterator；SendMessageTo；VoteToHalt

###3.1 Message Passing
    顶点之间的通信是直接通过发送消息，每条消息都包含了消息值和目标顶点的名称。消息值的数据类型是由用户通过Vertex类的模版参数来指定。
    在一个superstep中，一个顶点可以发送任意多的消息。当顶点V的Compute()方法在superstep S+1中被调用时，所有在superstep S中发送给顶点V的消息都可以通过一个迭代器来访问到。在该迭代器中并不保证消息的顺序，但是可以保证消息一定会被传送并且不会重复。
    dest_vertex并不一定是顶点V的相邻顶点。一个顶点可以从之前收到的消息中获取到其非相邻顶点的标识符，或者顶点标识符可以隐式的得到。
    当一个消息的目标顶点不存在时，便执行用户自定义的handlers。可以创建该不存在的顶点或从源顶点中删除这条边。

###3.2 Combiners
    Combine减少消息数量来减少网络传输和缓存开销。与MapReduce的Combiner同曲同工。
    默认关闭，要开启Combiner的功能，需要继承Combiner类，覆写其virtual函数Combine()。

###3.3 Aggregators
    可以做统计，如sum aggregate统计每个顶点的出度；
    可以做全局协调，如Compute()函数的一些逻辑分支可能在某些superstep中执行，直到and aggregator表明所有顶点都满足了某条件，之后执行另外的逻辑分支直到结束；又比如一个作用在顶点ID之上的min和max的aggregator，可以用来选定某顶点在整个计算过程中扮演某种角色等；
    还可以用来实现一个△-stepping最短路径算法所需要的分布式优先队列；
    要定义一个新的aggregator，用户需要继承预定义的Aggregator类，并定义在第一次接收到输入值后如何初始化，以及如何将接收到的多个值最后reduce成一个值。Aggregator操作也应该满足交换律和结合律；
    默认情况下，一个aggregator仅仅会对来自同一个superstep的输入进行聚合，但是有时也可能需要定义一个sticky aggregator，它可以从所有的supersteps中接收数据。这是非常有用的，比如要维护全局的边条数，那么就仅仅在增加和删除边的时候才调整这个值了；

###3.4 Topology Mutations
    有一些图算法可能需要改变图的整个拓扑结构。比如一个聚类算法，可能会将每个聚类替换成一个单一顶点，又比如一个最小生成树算法会删除所有除了组成树的边之外的其他边。正如用户可以在自定义的Compute()函数能发送消息，同样可以产生在图中增添和删除边或顶点的请求；
    同一个superstep中可能产生冲突的请求(如两个请求都要增加一个顶点V，但初始值不一样)，两个机制保证确定性：局部有序和handlers；
    局部有序：
        先点后边；
    handlers：
        用户可以在Vertex类中通过定义一个适当的handler函数来解决冲突；
    惰性协调机制，全局的拓扑改变在被apply之前不需要进行协调。对顶点V的修改引发的冲突由V自己来处理。

###3.5 Input and Output
    Reader、Writer

